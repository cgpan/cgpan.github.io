<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Linear Regression Explorer</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #3b82f6;
      --accent-2: #10b981;
      --accent-3: #f59e0b;
      --border: #e5e7eb;
      --shadow: 0 10px 24px rgba(0,0,0,0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 24px 28px 8px 28px;
    }
    h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      font-weight: 700;
    }
    p.lead {
      margin: 0 0 10px 0;
      color: var(--muted);
    }
    .container {
      padding: 18px 28px 28px 28px;
      display: grid;
      gap: 18px;
      grid-template-columns: 1fr;
    }
    .controls {
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: 14px;
      padding: 18px;
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: center;
    }
    .control-group label {
      display: block;
      font-size: 12px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .control-group select,
    .control-group input[type="range"] {
      width: 100%;
    }
    .control-group select {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      background: #fff;
      color: var(--text);
      font-size: 14px;
    }
    .value-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #eef2ff;
      color: #3730a3;
      font-weight: 600;
      font-size: 13px;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease;
      margin-right: 8px;
    }
    .btn:active { transform: scale(0.98); }
    .btn.secondary {
      background: #fff;
      border-color: var(--border);
      color: var(--text);
    }
    .grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px;
      min-height: 0;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }
    .panel h3 {
      margin: 0;
      font-size: 16px;
    }
    .canvas-wrap {
      position: relative;
    }
    canvas {
      width: 100%;
      height: 460px;
    }
    .stats {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .stat {
      background: #f9fafb;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
    }
    .equations {
      display: grid;
      gap: 8px;
      font-size: 14px;
      color: var(--text);
    }
    .equation-box {
      background: #f9fafb;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .footer-note {
      font-size: 13px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Simple Linear Regression Explorer</h1>
    <p class="lead">Visualize a population of 500 points, the true regression line, and one random sample of 50 points with its fitted line.</p>
    <p class="footer-note">By <a href="https://cpan.ai/" target="_blank" rel="noopener noreferrer">Chenguang Pan</a>.</p>
  </header>

  <div class="container">
    <div class="controls">
      <div class="control-group">
        <label for="scenarioSelect">Data Scenario</label>
        <select id="scenarioSelect">
          <option value="numeric">Linear regression with one numerical variable</option>
          <option value="binary">Linear regression with one binary variable</option>
          <option value="mixed">Linear regression with a binary + a numerical variable</option>
        </select>
      </div>
      <div class="control-group">
        <label>Population Size</label>
        <div class="value-pill">N = 500</div>
      </div>
      <div class="control-group">
        <label for="sampleSize">Sample Size</label>
        <input id="sampleSize" type="range" min="50" max="400" step="50" value="50" />
        <div class="value-pill">n = <span id="sampleSizeValue">50</span></div>
      </div>
      <div class="control-group">
        <label>Actions</label>
        <button id="drawSample" class="btn">Draw Sample</button>
        <button id="resetSample" class="btn secondary">Reset Sample</button>
        <button id="bestFit" class="btn secondary">Best Fit</button>
      </div>
      <div class="control-group">
        <label>Population Model</label>
        <div class="footer-note">True line is dashed with 80% opacity</div>
      </div>
    </div>

    <div class="grid">
      <div class="panel" style="grid-column: span 2;">
        <h3>Population and Sample (with Regression Lines)</h3>
        <div class="canvas-wrap">
          <canvas id="regCanvas" width="1100" height="520"></canvas>
        </div>
        <div class="stats">
          <span class="stat" id="popStats">Population: 500 points</span>
          <span class="stat" id="sampleStats">No sample drawn yet</span>
        </div>
      </div>

      <div class="panel">
        <h3>Notes</h3>
        <div class="footer-note" id="scenarioNote">
          The population points are shown at 30% opacity and the true line at 80% opacity. Adjust the sample size, draw a sample, and drag the fitted line to see residuals and MSE update.
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('regCanvas');
    const popStats = document.getElementById('popStats');
    const sampleStats = document.getElementById('sampleStats');
    const scenarioSelect = document.getElementById('scenarioSelect');
    const scenarioNote = document.getElementById('scenarioNote');
    const sampleSizeInput = document.getElementById('sampleSize');
    const sampleSizeValue = document.getElementById('sampleSizeValue');
    const drawSampleBtn = document.getElementById('drawSample');
    const resetSampleBtn = document.getElementById('resetSample');
    const bestFitBtn = document.getElementById('bestFit');

    const POP_SIZE = 500;
    let sampleSize = 50;
    const X1_MIN = 0;
    const X1_MAX = 100;

    const SCENARIOS = {
      numeric: {
        key: 'numeric',
        name: 'Linear regression with one numerical variable',
        formula: 'Y = β0 + β1X',
        note: 'Standard scatter plot with an OLS line. Dragging the fitted line is enabled in this mode.',
        trueModel: { b0: 10, b1: 0.7 },
        noiseSd: 15
      },
      binary: {
        key: 'binary',
        name: 'Linear regression with one binary variable',
        formula: 'Y = β0 + β1X, X ∈ {0,1}',
        note: 'Points are jittered around X=0 and X=1. Horizontal fitted lines show E[Y|X=0] and E[Y|X=1], and β1 is their difference.',
        trueModel: { b0: 24, b1: 14 },
        noiseSd: 10
      },
      mixed: {
        key: 'mixed',
        name: 'Linear regression with a binary + a numerical variable',
        formula: 'Y = β0 + β1X1 + β2X2',
        note: 'Groups are color-coded by X2. Two parallel lines are shown and their vertical gap corresponds to β2.',
        trueModel: { b0: 8, b1: 0.55, b2: 12 },
        noiseSd: 12
      }
    };

    let scenarioKey = 'numeric';

    let population = [];
    let sample = [];
    let sampleFit = null;
    let currentLine = null;
    let currentMSE = null;
    let isDragging = false;
    let dragStart = null;

    function normalRandom() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function activeScenario() {
      return SCENARIOS[scenarioKey];
    }

    function generatePopulation() {
      const scenario = activeScenario();
      if (scenario.key === 'numeric') {
        population = Array.from({ length: POP_SIZE }, () => {
          const x = X1_MIN + Math.random() * (X1_MAX - X1_MIN);
          const y = scenario.trueModel.b0 + scenario.trueModel.b1 * x + scenario.noiseSd * normalRandom();
          return { x, y };
        });
        return;
      }

      if (scenario.key === 'binary') {
        population = Array.from({ length: POP_SIZE }, () => {
          const xBinary = Math.random() < 0.5 ? 0 : 1;
          const y = scenario.trueModel.b0 + scenario.trueModel.b1 * xBinary + scenario.noiseSd * normalRandom();
          return {
            xBinary,
            y,
            jitter: (Math.random() - 0.5) * 0.22
          };
        });
        return;
      }

      population = Array.from({ length: POP_SIZE }, () => {
        const x1 = X1_MIN + Math.random() * (X1_MAX - X1_MIN);
        const x2 = Math.random() < 0.5 ? 0 : 1;
        const y = scenario.trueModel.b0 + scenario.trueModel.b1 * x1 + scenario.trueModel.b2 * x2 + scenario.noiseSd * normalRandom();
        return { x1, x2, y };
      });
    }

    function computeOLS(points, xAccessor) {
      const n = points.length;
      const meanX = points.reduce((sum, p) => sum + xAccessor(p), 0) / n;
      const meanY = points.reduce((sum, p) => sum + p.y, 0) / n;
      let num = 0;
      let den = 0;
      points.forEach(p => {
        const x = xAccessor(p);
        num += (x - meanX) * (p.y - meanY);
        den += (x - meanX) ** 2;
      });
      if (Math.abs(den) < 1e-9) {
        return { b0: meanY, b1: 0 };
      }
      const b1 = num / den;
      const b0 = meanY - b1 * meanX;
      return { b0, b1 };
    }

    function solveLinear3x3(matrix, vector) {
      const m = matrix.map((row, i) => [...row, vector[i]]);
      for (let col = 0; col < 3; col += 1) {
        let pivot = col;
        for (let row = col + 1; row < 3; row += 1) {
          if (Math.abs(m[row][col]) > Math.abs(m[pivot][col])) {
            pivot = row;
          }
        }
        if (Math.abs(m[pivot][col]) < 1e-12) return null;
        if (pivot !== col) [m[col], m[pivot]] = [m[pivot], m[col]];

        const pivotVal = m[col][col];
        for (let c = col; c < 4; c += 1) m[col][c] /= pivotVal;

        for (let row = 0; row < 3; row += 1) {
          if (row === col) continue;
          const factor = m[row][col];
          for (let c = col; c < 4; c += 1) {
            m[row][c] -= factor * m[col][c];
          }
        }
      }
      return { b0: m[0][3], b1: m[1][3], b2: m[2][3] };
    }

    function computeMultipleOLS(points) {
      const n = points.length;
      if (!n) return null;
      let sX1 = 0;
      let sX2 = 0;
      let sY = 0;
      let sX1X1 = 0;
      let sX2X2 = 0;
      let sX1X2 = 0;
      let sX1Y = 0;
      let sX2Y = 0;

      points.forEach(p => {
        sX1 += p.x1;
        sX2 += p.x2;
        sY += p.y;
        sX1X1 += p.x1 * p.x1;
        sX2X2 += p.x2 * p.x2;
        sX1X2 += p.x1 * p.x2;
        sX1Y += p.x1 * p.y;
        sX2Y += p.x2 * p.y;
      });

      const matrix = [
        [n, sX1, sX2],
        [sX1, sX1X1, sX1X2],
        [sX2, sX1X2, sX2X2]
      ];
      const vector = [sY, sX1Y, sX2Y];
      return solveLinear3x3(matrix, vector);
    }

    function computeFit(points) {
      if (!points.length) return null;
      const scenario = activeScenario();
      if (scenario.key === 'numeric') {
        return computeOLS(points, p => p.x);
      }
      if (scenario.key === 'binary') {
        return computeOLS(points, p => p.xBinary);
      }
      return computeMultipleOLS(points);
    }

    function getXRange() {
      if (scenarioKey === 'binary') {
        return { min: -0.4, max: 1.4 };
      }
      return { min: X1_MIN, max: X1_MAX };
    }

    function getXTicks() {
      if (scenarioKey === 'binary') {
        return [
          { value: 0, label: '0' },
          { value: 1, label: '1' }
        ];
      }
      return Array.from({ length: 6 }, (_, i) => {
        const x = X1_MIN + (i / 5) * (X1_MAX - X1_MIN);
        return { value: x, label: x.toFixed(0) };
      });
    }

    function getXForPoint(point) {
      if (scenarioKey === 'numeric') return point.x;
      if (scenarioKey === 'binary') return point.xBinary + (point.jitter || 0);
      return point.x1;
    }

    function predict(point, model) {
      if (!model) return null;
      if (scenarioKey === 'numeric') return model.b0 + model.b1 * point.x;
      if (scenarioKey === 'binary') return model.b0 + model.b1 * point.xBinary;
      return model.b0 + model.b1 * point.x1 + model.b2 * point.x2;
    }

    function getYRange() {
      const ys = population.map(p => p.y);
      if (sample.length) ys.push(...sample.map(p => p.y));
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);
      const pad = (maxY - minY) * 0.1 || 10;
      return { minY: minY - pad, maxY: maxY + pad };
    }

    function toCanvasX(x, width, padding) {
      const { min, max } = getXRange();
      return padding + ((x - min) / (max - min)) * (width - padding * 2);
    }

    function toCanvasY(y, height, padding, minY, maxY) {
      return height - padding - ((y - minY) / (maxY - minY)) * (height - padding * 2);
    }

    function drawAxes(ctx, width, height, padding, minY, maxY) {
      ctx.strokeStyle = '#d1d5db';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.moveTo(padding, height - padding);
      ctx.lineTo(padding, padding);
      ctx.stroke();

      ctx.fillStyle = '#6b7280';
      ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      getXTicks().forEach(tick => {
        const cx = toCanvasX(tick.value, width, padding);
        ctx.beginPath();
        ctx.moveTo(cx, height - padding);
        ctx.lineTo(cx, height - padding + 6);
        ctx.stroke();
        ctx.fillText(tick.label, cx, height - padding + 8);
      });

      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 5; i += 1) {
        const y = minY + (i / 5) * (maxY - minY);
        const cy = toCanvasY(y, height, padding, minY, maxY);
        ctx.beginPath();
        ctx.moveTo(padding - 6, cy);
        ctx.lineTo(padding, cy);
        ctx.stroke();
        ctx.fillText(y.toFixed(0), padding - 8, cy);
      }
    }

    function drawRoundedRect(ctx, x, y, width, height, radius) {
      const r = Math.min(radius, width / 2, height / 2);
      if (typeof ctx.roundRect === 'function') {
        ctx.beginPath();
        ctx.roundRect(x, y, width, height, r);
        return;
      }
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + width, y, x + width, y + height, r);
      ctx.arcTo(x + width, y + height, x, y + height, r);
      ctx.arcTo(x, y + height, x, y, r);
      ctx.arcTo(x, y, x + width, y, r);
      ctx.closePath();
    }

    function drawMixedLegend(ctx) {
      const items = [
        { label: 'Group X2 = 0', color: 'rgba(59, 130, 246, 1)' },
        { label: 'Group X2 = 1', color: 'rgba(245, 158, 11, 1)' }
      ];

      ctx.save();
      ctx.font = '13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      const padding = 10;
      const lineHeight = 22;
      const markerSize = 10;
      const textWidth = Math.max(...items.map(item => ctx.measureText(item.label).width));
      const boxWidth = padding * 3 + markerSize + textWidth;
      const boxHeight = padding * 2 + lineHeight * items.length;
      const x = canvas.width - boxWidth - 28;
      const y = 38;

      ctx.fillStyle = 'rgba(255, 255, 255, 0.88)';
      ctx.strokeStyle = 'rgba(229, 231, 235, 1)';
      drawRoundedRect(ctx, x, y, boxWidth, boxHeight, 12);
      ctx.fill();
      ctx.stroke();

      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      items.forEach((item, idx) => {
        const rowY = y + padding + idx * lineHeight + lineHeight / 2;
        ctx.fillStyle = item.color;
        ctx.beginPath();
        ctx.arc(x + padding + markerSize / 2, rowY, markerSize / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#111827';
        ctx.fillText(item.label, x + padding * 2 + markerSize, rowY);
      });
      ctx.restore();
    }

    function drawEquations(ctx) {
      const scenario = activeScenario();
      const trueEquation = scenario.key === 'mixed'
        ? `True: y = ${scenario.trueModel.b0.toFixed(2)} + ${scenario.trueModel.b1.toFixed(2)}x1 + ${scenario.trueModel.b2.toFixed(2)}x2`
        : `True: y = ${scenario.trueModel.b0.toFixed(2)} + ${scenario.trueModel.b1.toFixed(2)}x`;

      let sampleEquationText = 'Sample: ŷ = —';
      if (currentLine) {
        if (scenario.key === 'mixed') {
          sampleEquationText = `Sample: ŷ = ${currentLine.b0.toFixed(2)} + ${currentLine.b1.toFixed(2)}x1 + ${currentLine.b2.toFixed(2)}x2`;
        } else {
          sampleEquationText = `Sample: ŷ = ${currentLine.b0.toFixed(2)} + ${currentLine.b1.toFixed(2)}x`;
        }
      }
      const mseText = currentMSE === null ? 'MSE: —' : `MSE: ${currentMSE.toFixed(2)}`;
      const scenarioHint = scenario.key === 'binary'
        ? 'β1 = E[Y|X=1] − E[Y|X=0]'
        : scenario.key === 'mixed'
          ? 'Parallel-line gap = β2'
          : 'Slope = β1';

      ctx.save();
      const fontSize = 17;
      ctx.font = `${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
      ctx.strokeStyle = 'rgba(229, 231, 235, 1)';
      const padding = 14;
      const lineHeight = fontSize + 8;
      const lines = [trueEquation, sampleEquationText, scenarioHint];
      const textWidth = Math.max(
        ...lines.map(line => ctx.measureText(line).width)
      );
      const boxWidth = textWidth + padding * 2;
      const boxHeight = lineHeight * lines.length + padding * 2;
      const x = 70;
      const y = 40;

      drawRoundedRect(ctx, x, y, boxWidth, boxHeight, 12);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#111827';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      lines.forEach((line, index) => {
        ctx.fillText(line, x + padding, y + padding + index * lineHeight);
      });

      const mseBoxWidth = ctx.measureText(mseText).width + padding * 2;
      const mseBoxHeight = lineHeight + padding * 2;
      const mseX = x + boxWidth + 16;
      const mseY = y;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
      ctx.strokeStyle = 'rgba(229, 231, 235, 1)';
      drawRoundedRect(ctx, mseX, mseY, mseBoxWidth, mseBoxHeight, 12);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#111827';
      ctx.fillText(mseText, mseX + padding, mseY + padding);
      ctx.restore();
    }

    function drawPoints(ctx, points, color, alpha) {
      ctx.fillStyle = color;
      ctx.globalAlpha = alpha;
      const { minY, maxY } = getYRange();
      points.forEach(p => {
        const cx = toCanvasX(getXForPoint(p), canvas.width, 50);
        const cy = toCanvasY(p.y, canvas.height, 50, minY, maxY);
        ctx.beginPath();
        ctx.arc(cx, cy, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    function drawResiduals(ctx, points, line) {
      if (!points.length || !line) return;
      const { minY, maxY } = getYRange();
      ctx.save();
      ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
      ctx.setLineDash([3, 4]);
      ctx.lineWidth = 1.5;
      points.forEach(p => {
        const fittedY = predict(p, line);
        const cx = toCanvasX(getXForPoint(p), canvas.width, 50);
        const cy = toCanvasY(p.y, canvas.height, 50, minY, maxY);
        const fy = toCanvasY(fittedY, canvas.height, 50, minY, maxY);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx, fy);
        ctx.stroke();
      });
      ctx.restore();
    }

    function computeMSE(points, line) {
      if (!points.length || !line) return null;
      const sumSq = points.reduce((acc, p) => {
        const fitted = predict(p, line);
        const resid = p.y - fitted;
        return acc + resid * resid;
      }, 0);
      return sumSq / points.length;
    }

    function drawLine(ctx, b0, b1, color, dash = [], alpha = 1) {
      const { minY, maxY } = getYRange();
      const { min: x1, max: x2 } = getXRange();
      const y1 = b0 + b1 * x1;
      const y2 = b0 + b1 * x2;
      const cx1 = toCanvasX(x1, canvas.width, 50);
      const cx2 = toCanvasX(x2, canvas.width, 50);
      const cy1 = toCanvasY(y1, canvas.height, 50, minY, maxY);
      const cy2 = toCanvasY(y2, canvas.height, 50, minY, maxY);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dash);
      ctx.beginPath();
      ctx.moveTo(cx1, cy1);
      ctx.lineTo(cx2, cy2);
      ctx.stroke();
      ctx.restore();
    }

    function drawHorizontalSegment(ctx, xStart, xEnd, yValue, color, dash = [], alpha = 1) {
      const { minY, maxY } = getYRange();
      const cx1 = toCanvasX(xStart, canvas.width, 50);
      const cx2 = toCanvasX(xEnd, canvas.width, 50);
      const cy = toCanvasY(yValue, canvas.height, 50, minY, maxY);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.setLineDash(dash);
      ctx.beginPath();
      ctx.moveTo(cx1, cy);
      ctx.lineTo(cx2, cy);
      ctx.stroke();
      ctx.restore();
    }

    function drawBinaryLineLabel(ctx, x, yValue, text, color, alpha = 1) {
      const { minY, maxY } = getYRange();
      const cx = toCanvasX(x, canvas.width, 50);
      const cy = toCanvasY(yValue, canvas.height, 50, minY, maxY);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      const padX = 7;
      const padY = 4;
      const textWidth = ctx.measureText(text).width;
      const boxX = cx;
      const boxY = cy - 8;
      const boxWidth = textWidth + padX * 2;
      const boxHeight = 16;

      ctx.fillStyle = 'rgba(255, 255, 255, 0.88)';
      ctx.strokeStyle = 'rgba(229, 231, 235, 1)';
      drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, 8);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = color;
      ctx.fillText(text, boxX + padX, boxY + boxHeight / 2);
      ctx.restore();
    }

    function drawBinaryGroupLines(ctx, model, colors, dash = [], alpha = 1) {
      const yAt0 = model.b0;
      const yAt1 = model.b0 + model.b1;
      drawHorizontalSegment(ctx, -0.28, 0.28, yAt0, colors.group0, dash, alpha);
      drawHorizontalSegment(ctx, 0.72, 1.28, yAt1, colors.group1, dash, alpha);
      drawBinaryLineLabel(ctx, 0.31, yAt0, 'X=0', colors.group0, alpha);
      drawBinaryLineLabel(ctx, 1.31, yAt1, 'X=1', colors.group1, alpha);
    }

    function drawParallelLines(ctx, model, colors, dash = [], alpha = 1) {
      drawLine(ctx, model.b0, model.b1, colors.group0, dash, alpha);
      drawLine(ctx, model.b0 + model.b2, model.b1, colors.group1, dash, alpha);
    }

    function getLineCanvasPoints(line) {
      const { minY, maxY } = getYRange();
      const { min: x1, max: x2 } = getXRange();
      const y1 = line.b0 + line.b1 * x1;
      const y2 = line.b0 + line.b1 * x2;
      return {
        x1: toCanvasX(x1, canvas.width, 50),
        y1: toCanvasY(y1, canvas.height, 50, minY, maxY),
        x2: toCanvasX(x2, canvas.width, 50),
        y2: toCanvasY(y2, canvas.height, 50, minY, maxY)
      };
    }

    function getBinarySegmentCanvasPoints(yValue, xStart, xEnd) {
      const { minY, maxY } = getYRange();
      return {
        x1: toCanvasX(xStart, canvas.width, 50),
        y1: toCanvasY(yValue, canvas.height, 50, minY, maxY),
        x2: toCanvasX(xEnd, canvas.width, 50),
        y2: toCanvasY(yValue, canvas.height, 50, minY, maxY)
      };
    }

    function getDraggableSegments(line) {
      if (!line) return [];
      if (scenarioKey === 'numeric') {
        return [getLineCanvasPoints(line)];
      }
      if (scenarioKey === 'binary') {
        return [
          getBinarySegmentCanvasPoints(line.b0, -0.28, 0.28),
          getBinarySegmentCanvasPoints(line.b0 + line.b1, 0.72, 1.28)
        ];
      }
      return [
        getLineCanvasPoints(line),
        (() => {
          const shifted = { ...line, b0: line.b0 + line.b2 };
          return getLineCanvasPoints(shifted);
        })()
      ];
    }

    function distanceToCurrentLine(point) {
      if (!currentLine) return Infinity;
      const segments = getDraggableSegments(currentLine);
      return segments.reduce((best, seg) => {
        const value = distancePointToSegment(point.x, point.y, seg.x1, seg.y1, seg.x2, seg.y2);
        return Math.min(best, value);
      }, Infinity);
    }

    function distancePointToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
      const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
      const clamped = Math.max(0, Math.min(1, t));
      const cx = x1 + clamped * dx;
      const cy = y1 + clamped * dy;
      return Math.hypot(px - cx, py - cy);
    }

    function getCanvasPoint(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY
      };
    }

    function drawScene() {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const { minY, maxY } = getYRange();
      drawAxes(ctx, canvas.width, canvas.height, 50, minY, maxY);
      const scenario = activeScenario();

      if (scenario.key === 'mixed') {
        drawPoints(ctx, population.filter(p => p.x2 === 0), 'rgba(59, 130, 246, 1)', 0.3);
        drawPoints(ctx, population.filter(p => p.x2 === 1), 'rgba(245, 158, 11, 1)', 0.3);
        drawParallelLines(
          ctx,
          scenario.trueModel,
          { group0: 'rgba(59, 130, 246, 1)', group1: 'rgba(245, 158, 11, 1)' },
          [6, 6],
          0.8
        );
      } else if (scenario.key === 'binary') {
        drawPoints(ctx, population, 'rgba(59, 130, 246, 1)', 0.3);
        drawBinaryGroupLines(
          ctx,
          scenario.trueModel,
          { group0: 'rgba(59, 130, 246, 1)', group1: 'rgba(245, 158, 11, 1)' },
          [6, 6],
          0.85
        );
      } else {
        drawPoints(ctx, population, 'rgba(59, 130, 246, 1)', 0.3);
        drawLine(ctx, scenario.trueModel.b0, scenario.trueModel.b1, 'rgba(59, 130, 246, 1)', [6, 6], 0.8);
      }

      if (sample.length > 0) {
        if (scenario.key === 'mixed') {
          drawPoints(ctx, sample.filter(p => p.x2 === 0), 'rgba(37, 99, 235, 1)', 0.95);
          drawPoints(ctx, sample.filter(p => p.x2 === 1), 'rgba(217, 119, 6, 1)', 0.95);
        } else {
          drawPoints(ctx, sample, 'rgba(239, 68, 68, 1)', 0.95);
        }
        if (currentLine) {
          drawResiduals(ctx, sample, currentLine);
          if (scenario.key === 'mixed') {
            drawParallelLines(
              ctx,
              currentLine,
              { group0: 'rgba(37, 99, 235, 1)', group1: 'rgba(217, 119, 6, 1)' }
            );
          } else if (scenario.key === 'binary') {
            drawBinaryGroupLines(
              ctx,
              currentLine,
              { group0: 'rgba(37, 99, 235, 1)', group1: 'rgba(217, 119, 6, 1)' }
            );
          } else {
            drawLine(ctx, currentLine.b0, currentLine.b1, 'rgba(239, 68, 68, 1)', [], 1);
          }
        }
      }

      if (scenario.key === 'mixed') {
        drawMixedLegend(ctx);
      }

      drawEquations(ctx);
      updateMSE();
    }

    function drawSample() {
      sample = [];
      const indices = Array.from({ length: population.length }, (_, i) => i);
      for (let i = indices.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      for (let i = 0; i < sampleSize; i += 1) {
        sample.push(population[indices[i]]);
      }
      sampleFit = computeFit(sample);
      currentLine = sampleFit ? { ...sampleFit } : null;
      sampleStats.textContent = `Sample: ${sampleSize} points`;
      updateMSE();
      drawScene();
    }

    function resetSample() {
      sample = [];
      sampleFit = null;
      currentLine = null;
      sampleStats.textContent = 'No sample drawn yet';
      currentMSE = null;
      drawScene();
    }

    function updateMSE() {
      currentMSE = computeMSE(sample, currentLine);
    }

    function updateSampleSize() {
      sampleSize = Number(sampleSizeInput.value);
      sampleSizeValue.textContent = sampleSize;
    }

    function bestFit() {
      if (!sampleFit) return;
      currentLine = { ...sampleFit };
      updateMSE();
      drawScene();
    }

    function onMouseDown(evt) {
      if (!currentLine) return;
      const point = getCanvasPoint(evt);
      const dist = distanceToCurrentLine(point);
      if (dist <= 8) {
        isDragging = true;
        dragStart = { data: point, line: { ...currentLine } };
        canvas.style.cursor = 'grabbing';
      }
    }

    function onMouseMove(evt) {
      const point = getCanvasPoint(evt);
      if (!isDragging || !dragStart) {
        const dist = distanceToCurrentLine(point);
        canvas.style.cursor = dist <= 8 ? 'grab' : 'default';
        return;
      }

      const { minY, maxY } = getYRange();
      const padding = 50;
      const dataY = maxY - ((point.y - padding) / (canvas.height - padding * 2)) * (maxY - minY);
      const startDataY = maxY - ((dragStart.data.y - padding) / (canvas.height - padding * 2)) * (maxY - minY);
      const deltaY = dataY - startDataY;
      currentLine = {
        ...dragStart.line,
        b0: dragStart.line.b0 + deltaY
      };
      updateMSE();
      drawScene();
    }

    function onMouseUp() {
      isDragging = false;
      dragStart = null;
      canvas.style.cursor = 'default';
    }

    function onMouseLeave() {
      if (!isDragging) {
        canvas.style.cursor = 'default';
      }
    }

    function updateScenarioUI() {
      const scenario = activeScenario();
      scenarioNote.textContent = scenario.note;
      popStats.textContent = `Population: ${POP_SIZE} points • ${scenario.formula}`;
      sampleStats.textContent = 'No sample drawn yet';
    }

    function setScenario(nextScenarioKey) {
      scenarioKey = nextScenarioKey;
      isDragging = false;
      dragStart = null;
      sample = [];
      sampleFit = null;
      currentLine = null;
      currentMSE = null;
      generatePopulation();
      updateScenarioUI();
      drawScene();
    }

    function init() {
      setScenario(scenarioKey);
    }

    drawSampleBtn.addEventListener('click', drawSample);
    resetSampleBtn.addEventListener('click', resetSample);
    bestFitBtn.addEventListener('click', bestFit);
    sampleSizeInput.addEventListener('input', updateSampleSize);
    scenarioSelect.addEventListener('change', () => setScenario(scenarioSelect.value));
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseleave', onMouseLeave);
    window.addEventListener('mouseup', onMouseUp);

    updateSampleSize();
    init();
  </script>
</body>
</html>
